% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/log_scores.R
\name{log_scores}
\alias{log_scores}
\alias{log_scores.default}
\alias{log_scores.kde}
\alias{log_scores.lm}
\alias{log_scores.gam}
\title{Log scores}
\usage{
log_scores(object, loo = FALSE, ...)

\method{log_scores}{default}(
  object,
  loo = FALSE,
  h = kde_bandwidth(object),
  H = kde_bandwidth(object),
  ...
)

\method{log_scores}{kde}(object, loo = FALSE, ...)

\method{log_scores}{lm}(object, loo = FALSE, ...)

\method{log_scores}{gam}(object, loo = FALSE, ...)
}
\arguments{
\item{object}{A model object or a numerical data set.}

\item{loo}{Should leave-one-out log scores be computed?}

\item{...}{Other arguments are ignored.}

\item{h}{Bandwidth for univariate kernel density estimate. Default is \code{\link{kde_bandwidth}}.}

\item{H}{Bandwidth for multivariate kernel density estimate. Default is \code{\link{kde_bandwidth}}.}
}
\value{
A numerical vector containing either the log scores, or the log LOO scores.
}
\description{
Compute log scores or leave-one-out log scores from a model or
a kernel density estimate of a data set.
The log scores are defined as minus the log of the conditional density,
or kernel density estimate, at each observation.
The leave-one-out log scores (or log LOO scores) are obtained by estimating the conditional density
or kernel density estimate using all other observations.
}
\details{
If the first argument is a numerical vector or matrix, then
a kernel density estimate is computed, using a Gaussian kernel,
with default bandwidth given by a robust normal reference rule.
Otherwise the model is used to compute the conditional
density function at each observation, from which the log scores (or
possibly the log LOO scores) are obtained.
}
\examples{
of <- oldfaithful |>
  filter(duration < 7000, waiting < 7000) |>
  mutate(
    logscores = log_scores(cbind(duration, waiting)),
    loglooscores = log_scores(cbind(duration, waiting), loo = TRUE),
    lookout_prob = lookout(logscores, loglooscores)
  )
of |>
  ggplot(aes(x = duration, y = waiting, color = lookout_prob < 0.01)) +
  geom_point()
of <- oldfaithful |>
  filter(duration < 7000, waiting < 7000)
f_kde <- kde(of[,2:3], H = kde_bandwidth(of[,2:3]))
of |>
  mutate(
    logscores = log_scores(f_kde),
    loglooscores = log_scores(f_kde, loo = TRUE),
    lookout_prob = lookout(logscores, loglooscores)
  ) |>
  ggplot(aes(x = duration, y = waiting, color = lookout_prob < 0.01)) +
  geom_point()
shiraz <- wine_reviews |> filter(variety \%in\% c("Shiraz", "Syrah"))
fit_wine <- lm(log(price) ~ points, data = shiraz)
shiraz |>
  mutate(
    logscore = log_scores(fit_wine),
    loglooscore = log_scores(fit_wine, loo = TRUE),
    lookout_prob = lookout(logscore, loglooscore)
  ) |>
  ggplot(aes(x = points, y = price, color = lookout_prob < 0.02)) +
  geom_jitter(height = 0, width = 0.2) +
  scale_y_log10()
shiraz <- wine_reviews |> filter(variety \%in\% c("Shiraz", "Syrah"))
fit_wine <- mgcv::gam(log(price) ~ s(points), data = shiraz)
shiraz |>
  mutate(
    logscore = log_scores(fit_wine),
    lookout_prob = lookout(logscore)
  ) |>
  ggplot(aes(x = points, y = price, color = lookout_prob < 0.02)) +
  geom_jitter(height = 0, width = 0.2) +
  scale_y_log10()
}
\seealso{
\code{\link{kde_bandwidth}}
\code{\link[ks]{kde}}

\code{\link{kde_bandwidth}}
\code{\link[ks]{kde}}
}
\author{
Rob J Hyndman
}
